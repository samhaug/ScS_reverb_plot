#!/home/samhaug/anaconda2/bin/python

import obspy
import numpy as np
import seispy
from scipy.signal import tukey
from obspy.taup import TauPyModel
from matplotlib import pyplot as plt
from os import listdir
from scipy.signal import correlate
from scipy.signal import argrelextrema


'''
After you have found the best fit perturbed PREM model that explains
the traveltimes of ScS_n, use this function to find the best event depth
to explain depth phase separation.
'''

def find_ttimes(tr):
    '''
    Find the traveltimes of ScS reverberations for the 660
    '''
    gcarc = tr.stats.sac['gcarc']
    evdp = tr.stats.sac['evdp']
    time_d = {}
    phase_list = [
                  'ScSScS',
                  'sScSScS',

                  'ScSScSScS',
                  'sScSScSScS',

                  'ScSScSScSScS',
                  'sScSScSScSScS',

                  'ScSScSScSScSScS',
                  'sScSScSScSScSScS',
                 ]
    arrivals = model.get_travel_times(source_depth_in_km=evdp,
                                      distance_in_degree=gcarc,
                                      phase_list = phase_list)
    for i,j in enumerate(phase_list):
        time_d[j] = arrivals[i].time
    return time_d

def strip_reverb(tr,time_d):
    '''
    Use a tukey window to mask an axisem
    trace and only pass the reverberations
    '''
    sr = tr.stats.sampling_rate
    npts = tr.stats.npts
    masked_trace = tr.copy()

    def make_mask(phase):
        S = time_d[phase]
        sS = time_d['s'+phase]
        diff = int(abs(sS-S))
        window = (S-5,S+2*diff+38)
        t = tukey(int((window[1]-window[0])*sr),0.2)
        start = np.zeros(int(window[0]*sr))
        end = np.zeros(npts-int(window[1]*sr))
        mask = np.hstack((start,t,end))
        if len(mask) > len(tr.data):
            mask = mask[0:len(mask)-len(tr.data)]
        if len(mask) < len(tr.data):
            mask = np.hstack((mask,np.zeros(len(tr.data)-len(mask))))
        return mask

    m1 = make_mask('ScSScS')
    m2 = make_mask('ScSScSScS')
    m3 = make_mask('ScSScSScSScS')
    masked_trace.data = (m1+m2+m3)*tr.data
    return masked_trace

def setup_data(data_dir,st_ind):
    st_data = obspy.read(data_dir+'FJ_clean.pk')
    st_data.filter('bandpass',freqmax=1/25.,freqmin=1/60.)
    st_data = seispy.data.normalize_on_envelope(st_data)
    st_data = seispy.data.align_on_phase(st_data,phase=['ScSScS'],a_min=False)
    data_tr = seispy.data.phase_window(st_data[st_ind],['ScSScS'],window=(-10,2050))
    data_tr.interpolate(1)
    return data_tr

def select_reverb_times(data_tr):
    fig,ax = plt.subplots(figsize=(20,5))
    t = np.linspace(0,data_tr.stats.endtime-data_tr.stats.starttime,
                    num=data_tr.stats.npts)

    coord_list = []
    def onclick(event):
        print('button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %
        (event.button, event.x, event.y, event.xdata, event.ydata))
        coord_list.append(event.xdata)
    cid = fig.canvas.mpl_connect('button_press_event', onclick)
    ax.plot(data_tr.data)
    ax.set_xlim(t.min(),t.max())
    plt.show()

    true_max = []
    for ii in coord_list:
        idx = int(ii)
        shift = np.argmax(data_tr[idx-15:idx+15])-15
        max = idx+shift
        true_max.append(max)

    max1 = true_max[1]-true_max[0]
    max2 = true_max[3]-true_max[2]
    max3 = true_max[5]-true_max[4]
    dphase = (max1+max2+max3)/3.
    return dphase


def find_depth(data_tr,dphase,model):
    model = TauPyModel(model=model)
    dp_start = data_tr.stats.sac['evdp']
    gcarc = data_tr.stats.sac['gcarc']


data_dir = '/home/samhaug/work1/ScS_reverb_data/20160130/'
st_ind = 12

data_tr = setup_data(data_dir,st_ind)
dphase = select_reverb_times(data_tr)

    model = TauPyModel(model='prem_p2.5')














