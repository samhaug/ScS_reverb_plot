#!/home/samhaug/anaconda2/bin/python

import obspy
import numpy as np
import seispy
from scipy.signal import tukey
from obspy.taup import TauPyModel
from matplotlib import pyplot as plt
from os import listdir
from scipy.signal import correlate
from matplotlib import pylab as p

'''
Use this script as a tool for checking what moment tensor perturbation best
explains depth phase amplitudes. This script plots each trace separately.
'''

### Change data and simulation here.
sim_dir = '/home/samhaug/work1/ScS_reverb_sims/mineos/cmt_np_pert/'
data_dir = '/home/samhaug/work1/ScS_reverb_data/20160130/'

class DragHandler(object):
    """ A simple class to handle Drag n Drop.

    This is a simple example, which works for Text objects only.
    """
    def __init__(self, figure=None) :
        """ Create a new drag handler and connect it to the figure's event system.
        If the figure handler is not given, the current figure is used instead
        """
        if figure is None : figure = p.gcf()
        # simple attibute to store the dragged text object
        self.dragged = None

        # Connect events and callbacks
        figure.canvas.mpl_connect("pick_event", self.on_pick_event)
        figure.canvas.mpl_connect("button_release_event", self.on_release_event)

    def on_pick_event(self, event):
        " Store which text object was picked and were the pick event occurs."

        if event.artist.get_label() == 'sim':
            self.dragged = event.artist
            self.xdata = event.artist.get_data()[0]
            self.ydata = event.artist.get_data()[1]
            self.pick_pos = event.mouseevent.xdata
        return True

    def on_release_event(self, event):
        " Update text position and redraw"

        if self.dragged is not None :
            newx = event.xdata
            newy = np.roll(self.ydata,int(newx-self.pick_pos))
            self.dragged.set_data(self.xdata,newy)
            self.dragged = None
            p.draw()
        return True

def compare_plot(sts,std,ax,title):

    for idx,tr in enumerate(sts):
        ax.tick_params(axis='both', which='major', labelsize=3)
        ax.set_ylim(-1,len(sts))
        ax.set_title(title,size=7)
        ax.grid()

        ax.plot(1.5*idx+std[idx].data,alpha=0.7,color='k')
        ax.plot(1.5*idx+sts[idx].data,alpha=0.7,color='r',
                picker=True,label='sim',pickradius=15)

fig,ax_list = plt.subplots(1,5,figsize=(20,30))

sim_list = listdir(sim_dir)
sim_list.sort()
include_list = [-20,-25,-30,-35,-40]

for ii in sim_list:
    if int(ii.split('_')[1]) not in include_list:
        sim_list.remove(ii)

std = obspy.read(data_dir+'FJ_clean.pk')
std.sort(['station'])
std = std[::2]
std.interpolate(1)
std = seispy.data.align_on_phase(std,phase=['ScSScS'],a_min=False)

for idx,tr in enumerate(std):
    std[idx] = seispy.data.phase_window(tr,['ScSScS'],window=(-10,2050))
    std[idx].data *= 1./std[idx].data.max()

for idx,ax in enumerate(ax_list):
    print idx

    model = TauPyModel(model='prem')
    model_sim = TauPyModel(model='prem_p2.5')

    sts = obspy.read(sim_dir+sim_list[idx]+'/st_T.pk')
    sts.sort(['station'])
    sts = sts[::2]
    sts.filter('bandpass',freqmax=1/25.,freqmin=1/60.)
    sts.interpolate(1)
    sts.integrate()
    sts.normalize()
    sts = seispy.data.align_on_phase(sts,phase=['ScSScS'],
                                     a_min=False)
    for idy,tr in enumerate(sts):
        sts[idy] = seispy.data.phase_window(tr,['ScSScS'],window=(-10,2050))
        sts[idy].stats.starttime = std[idy].stats.starttime
        sts[idy].stats.sac['gcarc'] = std[idy].stats.sac['gcarc']
        sts[idy].normalize()

    compare_plot(sts,std,ax,sim_list[idx])

dragh = DragHandler()
plt.tight_layout()
plt.show()

